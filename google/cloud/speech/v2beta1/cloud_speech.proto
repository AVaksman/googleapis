// Copyright 2019 Google LLC.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//

syntax = "proto3";

package google.cloud.speech.v2beta1;

import "google/api/annotations.proto";
import "google/api/field_behavior.proto";
import "google/longrunning/operations.proto";
import "google/protobuf/any.proto";
import "google/protobuf/duration.proto";
import "google/protobuf/timestamp.proto";
import "google/rpc/status.proto";
import "google/api/client.proto";

option cc_enable_arenas = true;
option go_package = "google.golang.org/genproto/googleapis/cloud/speech/v2beta1;speech";
option java_multiple_files = true;
option java_outer_classname = "SpeechProto";
option java_package = "com.google.cloud.speech.v2beta1";

// Service that implements Google Cloud Speech API.
service Speech {
  option (google.api.default_host) = "speech.googleapis.com";
  option (google.api.oauth_scopes) = "https://www.googleapis.com/auth/cloud-platform";

  // Performs synchronous speech recognition: receive results after all audio
  // has been sent and processed.
  rpc Recognize(RecognizeRequest) returns (RecognizeResponse) {
    option (google.api.http) = {
      post: "/v2beta1/{parent=projects/*/locations/*}:recognize"
      body: "*"
      additional_bindings {
        post: "/v2beta1/{parent=projects/*}:recognize"
        body: "*"
      }
    };
  }

  // Performs asynchronous speech recognition: receive results via the
  // google.longrunning.Operations interface. Returns either an
  // `Operation.error` or an `Operation.response` which contains
  // a `LongRunningRecognizeResponse` message.
  // For more information on asynchronous speech recognition, see the
  // [how-to](https://cloud.google.com/speech-to-text/docs/async-recognize).
  rpc LongRunningRecognize(LongRunningRecognizeRequest) returns (google.longrunning.Operation) {
    option (google.api.http) = {
      post: "/v2beta1/{parent=projects/*/locations/*}:longRunningRecognize"
      body: "*"
      additional_bindings {
        post: "/v2beta1/{parent=projects/*}:longRunningRecognize"
        body: "*"
      }
    };
  }

  // Performs bidirectional streaming speech recognition: receive results while
  // sending audio. This method is only available via the gRPC API (not REST).
  rpc StreamingRecognize(stream StreamingRecognizeRequest) returns (stream StreamingRecognizeResponse) {
  }
}

// The top-level message sent by the client for the `Recognize` method.
message RecognizeRequest {
  // Required. Provides information to the recognizer that specifies how to process the
  // request.
  RecognitionConfig config = 1 [(google.api.field_behavior) = REQUIRED];

  // Required. The audio data to be recognized.
  RecognitionAudio audio = 2 [(google.api.field_behavior) = REQUIRED];

  // Required. Target project or location to make a call.
  //
  // Format: `projects/{project-id}` or
  // `projects/{project-id}/locations/us-west`.
  // Only support location ID `us-west` for now.
  string parent = 3 [(google.api.field_behavior) = REQUIRED];
}

// The top-level message sent by the client for the `LongRunningRecognize`
// method.
message LongRunningRecognizeRequest {
  // Required. Provides information to the recognizer that specifies how to process the
  // request.
  RecognitionConfig config = 1 [(google.api.field_behavior) = REQUIRED];

  // Required. The audio data to be recognized.
  RecognitionAudio audio = 2 [(google.api.field_behavior) = REQUIRED];

  // Required. Target project or location to make a call.
  //
  // Format: `projects/{project-id}` or
  // `projects/{project-id}/locations/us-west`.
  // Only support location ID `us-west` for now.
  string parent = 3 [(google.api.field_behavior) = REQUIRED];
}

// The top-level message sent by the client for the `StreamingRecognize` method.
// Multiple `StreamingRecognizeRequest` messages are sent. The first message
// must contain a `streaming_config` message and must not contain
// `audio_content`. All subsequent messages must contain `audio_content` and
// must not contain a `streaming_config` message.
message StreamingRecognizeRequest {
  // The streaming request, which is either a streaming config or audio content.
  oneof streaming_request {
    // Provides information to the recognizer that specifies how to process the
    // request. The first `StreamingRecognizeRequest` message must contain a
    // `streaming_config`  message.
    StreamingRecognitionConfig streaming_config = 1;

    // The audio data to be recognized. Sequential chunks of audio data are sent
    // in sequential `StreamingRecognizeRequest` messages. The first
    // `StreamingRecognizeRequest` message must not contain `audio_content` data
    // and all subsequent `StreamingRecognizeRequest` messages must contain
    // `audio_content` data. The audio bytes must be encoded as specified in
    // `RecognitionConfig`. Note: as with all bytes fields, proto buffers use a
    // pure binary representation (not base64). See
    // [content limits](https://cloud.google.com/speech-to-text/quotas#content).
    bytes audio_content = 2;
  }

  // Required. Target project or location to make a call.
  //
  // Format: `projects/{project-id}` or
  // `projects/{project-id}/locations/us-west`.
  // Only support location ID `us-west` for now.
  string parent = 3 [(google.api.field_behavior) = REQUIRED];
}

// Provides information to the recognizer that specifies how to process the
// request.
message StreamingRecognitionConfig {
  // Required. Provides information to the recognizer that specifies how to process the
  // request.
  RecognitionConfig config = 1 [(google.api.field_behavior) = REQUIRED];

  // Optional. If `false` or omitted, the recognizer will perform continuous
  // recognition (continuing to wait for and process audio even if the user
  // pauses speaking) until the client closes the input stream (gRPC API) or
  // until the maximum time limit has been reached. May return multiple
  // [StreamingRecognitionResult][google.cloud.speech.v2beta1.StreamingRecognitionResult]s with the `is_final` flag set to `true`.
  //
  // If `true`, the recognizer will detect a single spoken utterance. When it
  // detects that the user has paused or stopped speaking, it will return an
  // `END_OF_SINGLE_UTTERANCE` event and cease recognition. It will return no
  // more than one `StreamingRecognitionResult` with the `is_final` flag set to
  // `true`.
  bool single_utterance = 2 [(google.api.field_behavior) = OPTIONAL];

  // Optional. If `true`, interim results (tentative hypotheses) may be returned as they
  // become available (these interim results are indicated with the
  // `is_final=false` flag).
  // If `false` or omitted, only `is_final=true` result(s) are returned.
  bool interim_results = 3 [(google.api.field_behavior) = OPTIONAL];
}

// Provides information to the recognizer that specifies how to process the
// request.
message RecognitionConfig {
  // Optional. Encoding of audio data sent in all `RecognitionAudio` messages.
  //
  // Supported formats:
  //
  // - `linear16`
  //
  //   Uncompressed 16-bit signed little-endian samples (Linear PCM).
  //
  // - `flac`
  //
  //   `flac` (Free Lossless Audio Codec) is the recommended encoding
  //   because it is lossless--therefore recognition is not compromised--and
  //   requires only about half the bandwidth of `linear16`.
  //
  // - `mulaw`
  //
  //   8-bit samples that compand 14-bit audio samples using G.711 PCMU/mu-law.
  //
  // - `amr`
  //
  //   Adaptive Multi-Rate Narrowband codec. `sample_rate_hertz` must be 8000.
  //
  // - `amr-wb`
  //
  //   Adaptive Multi-Rate Wideband codec. `sample_rate_hertz` must be 16000.
  //
  // - `ogg-opus`
  //
  //   Opus encoded audio frames in Ogg container
  //   ([OggOpus](https://wiki.xiph.org/OggOpus)).
  //   `sample_rate_hertz` must be one of 8000, 12000, 16000, 24000, or 48000.
  //
  // - `speex-with-header-byte`
  //
  //   Although the use of lossy encodings is not recommended, if a very low
  //   bitrate encoding is required, `ogg-opus` is highly preferred over
  //   Speex encoding. The [Speex](https://speex.org/)  encoding supported by
  //   Cloud Speech API has a header byte in each block, as in MIME type.
  //   `audio/x-speex-with-header-byte`.
  //   It is a variant of the RTP Speex encoding defined in
  //   [RFC 5574](https://tools.ietf.org/html/rfc5574).
  //   The stream is a sequence of blocks, one block per RTP packet. Each block
  //   starts with a byte containing the length of the block, in bytes, followed
  //   by one or more frames of Speex data, padded to an integral number of
  //   bytes (octets) as specified in RFC 5574. In other words, each RTP header
  //   is replaced with a single byte containing the block length. Only Speex
  //   wideband is supported. `sample_rate_hertz` must be 16000.
  //   All encodings support only 1 channel (mono) audio, unless the
  //   `audio_channel_count` and `enable_separate_recognition_per_channel`
  //   fields are set.
  //
  // - `mp3`
  //
  //   MP3 audio. Support all standard MP3 bitrates (which range from 32-320
  //   kbps). When using this encoding, `sample_rate_hertz` can be optionally
  //   unset if not known.
  //
  // For best results, the audio source should be captured and transmitted using
  // a lossless encoding (`flac` or `linear16`). The accuracy of the
  // speech recognition can be reduced if lossy codecs are used to capture or
  // transmit audio, particularly if background noise is present. Lossy codecs
  // include `mulaw`, `amr`, `amr-wb`, `ogg-opus`,
  // `audio/speex_with_header_byte`, and `mp3`.
  //
  // The `flac` and `linear16` audio file formats include a header that
  // describes the included audio content. You can request recognition for
  // `linear16` files that contain either `linear16` or `mulaw`
  // encoded audio.
  // If you send `flac` or `linear16` audio file format in your request,
  // you do not need to specify a `audio_encoding`; the audio
  // encoding format is determined from the file header. If you specify
  // a `audio_encoding` when you send  send `flac` or `linear16` audio, the
  // encoding configuration must match the encoding described in the audio
  // header; otherwise the request returns an
  // [google.rpc.Code.INVALID_ARGUMENT][google.rpc.Code.INVALID_ARGUMENT] error code.
  string audio_encoding = 1 [(google.api.field_behavior) = OPTIONAL];

  // Optional. Sample rate in Hertz of the audio data sent in all `RecognitionAudio`
  // messages. Valid values are: 8000-48000. 16000 is optimal. For best results,
  // set the sampling rate of the audio source to 16000 Hz. If that is not
  // possible, use the native sample rate of the audio source (instead of
  // re-sampling).
  // This field is optional for `flac` and `linear16` audio files, but is
  // required for all other audio formats. For details, see [audio_encoding][google.cloud.speech.v2beta1.RecognitionConfig.audio_encoding].
  int32 sample_rate_hertz = 2 [(google.api.field_behavior) = OPTIONAL];

  // Optional. The number of channels in the input audio data.
  // ONLY set this for MULTI-CHANNEL recognition.
  // Valid values for `linear16` and `flac` are `1`-`8`.
  // Valid values for `ogg-opus` are `1`-`254`.
  // Valid value for `mulaw`, `amr`, `amr-wb` and `speex-with-header-byte` is
  // only `1`.
  // If `0` or omitted, defaults to one channel (mono).
  // Note: We only recognize the first channel by default.
  // To perform independent recognition on each channel set
  // `enable_separate_recognition_per_channel` to `true`.
  int32 audio_channel_count = 7 [(google.api.field_behavior) = OPTIONAL];

  // Optional. This needs to be set to `true` explicitly and `audio_channel_count` > 1 to
  // get each channel recognized separately. The recognition result will contain
  // a `channel_tag` field to state which channel that result belongs to. If
  // this is not true, we will only recognize the first channel. The request is
  // billed cumulatively for all channels recognized: `audio_channel_count`
  // multiplied by the length of the audio.
  bool enable_separate_recognition_per_channel = 12 [(google.api.field_behavior) = OPTIONAL];

  // Required. The language of the supplied audio as a
  // [BCP-47](https://www.rfc-editor.org/rfc/bcp/bcp47.txt) language tag.
  // Example: "en-US".
  // See [Language
  // Support](https://cloud.google.com/speech-to-text/docs/languages) for a list
  // of the currently supported language codes.
  string language_code = 3 [(google.api.field_behavior) = REQUIRED];

  // Optional. A list of up to 3 additional
  // [BCP-47](https://www.rfc-editor.org/rfc/bcp/bcp47.txt) language tags,
  // listing possible alternative languages of the supplied audio.
  // See [Language
  // Support](https://cloud.google.com/speech-to-text/docs/languages) for a list
  // of the currently supported language codes. If alternative languages are
  // listed, recognition result will contain recognition in the most likely
  // language detected including the main language_code. The recognition result
  // will include the language tag of the language detected in the audio. Note:
  // This feature is only supported for Voice Command and Voice Search use cases
  // and performance may vary for other use cases (e.g., phone call
  // transcription).
  repeated string alternative_language_codes = 16 [(google.api.field_behavior) = OPTIONAL];

  // Optional. Maximum number of recognition hypotheses to be returned.
  // Specifically, the maximum number of `SpeechRecognitionAlternative` messages
  // within each `SpeechRecognitionResult`.
  // The server may return fewer than `max_alternatives`.
  // Valid values are `0`-`30`. A value of `0` or `1` will return a maximum of
  // one. If omitted, will return a maximum of one.
  int32 max_alternatives = 4 [(google.api.field_behavior) = OPTIONAL];

  // Optional. If set to `true`, the server will attempt to filter out
  // profanities, replacing all but the initial character in each filtered word
  // with asterisks, e.g. "f***". If set to `false` or omitted, profanities
  // will not be filtered out.
  bool profanity_filter = 5 [(google.api.field_behavior) = OPTIONAL];

  // Optional. array of [SpeechContext][google.cloud.speech.v2beta1.SpeechContext].
  // A means to provide context to assist the speech recognition. For more
  // information, see [Phrase
  // Hints](https://cloud.google.com/speech-to-text/docs/basics#phrase-hints).
  repeated SpeechContext speech_contexts = 6 [(google.api.field_behavior) = OPTIONAL];

  // Optional. If `true`, the top result includes a list of words and the start and end
  // time offsets (timestamps) for those words. If `false`, no word-level time
  // offset information is returned. The default is `false`.
  bool enable_word_time_offsets = 8 [(google.api.field_behavior) = OPTIONAL];

  // Optional. If `true`, the top result includes a list of words and the confidence for
  // those words. If `false`, no word-level confidence nformation is returned.
  // The default is `false`.
  bool enable_word_confidence = 15 [(google.api.field_behavior) = OPTIONAL];

  // Optional. If `true`, adds punctuation to recognition result hypotheses.
  // This feature is only available in select languages. Setting this for
  // requests in other languages has no effect at all.
  // The default `false` value does not add punctuation to result hypotheses.
  // Note: This is currently offered as an experimental service, complimentary
  // to all users. In the future this may be exclusively available as a
  // premium feature.
  bool enable_automatic_punctuation = 11 [(google.api.field_behavior) = OPTIONAL];

  // Config to enable speaker diarization and set additional parameters to make
  // diarization better suited for your application.
  // Note: When this is enabled, we send all the words from the beginning of the
  // audio for the top alternative in every consecutive STREAMING responses.
  // This is done in order to improve our speaker tags as our models learn to
  // identify the speakers in the conversation over time.
  // For non-streaming requests, the diarization results will be provided only
  // in the top alternative of the FINAL `SpeechRecognitionResult`.
  SpeakerDiarizationConfig diarization_config = 17;

  // Optional. Metadata regarding this request.
  RecognitionMetadata metadata = 9 [(google.api.field_behavior) = OPTIONAL];

  // Optional. Which model to select for the given request.
  // Support both pre-built and custom models.
  // Select the model best suited to your domain to get best results.
  // If a model is not explicitly specified, then we auto-select a model based
  // on the parameters in the RecognitionConfig.
  //
  // General (pre-built) models:
  //
  // - `projects/{project-id}/locations/{location-id}/models/command_and_search`
  //
  //    Best for short queries such as voice commands or voice search.
  //
  // -  `projects/{project-id}/locations/{location-id}/models/phone_call`
  //
  //    Best for audio that originated from a phone call (typically recorded
  //    at an 8khz sampling rate).
  //
  // -  `projects/{project-id}/locations/{location-id}/models/video`
  //
  //    Best for audio that originated from from video or includes multiple
  //    speakers. Ideally the audio is recorded at a 16khz or greater sampling
  //    rate. This is a premium model that costs more than the standard rate.
  //
  // -  `projects/{project-id}/locations/{location-id}/models/default`
  //
  //    Best for audio that is not one of the specific audio models.
  //    For example, long-form audio. Ideally the audio is high-fidelity,
  //    recorded at a 16khz or greater sampling rate.
  //
  // Per-project (custom) models:
  //
  //    `projects/{project-id}/locations/{location-id}/models/STT{model-id}`
  repeated string models = 18 [(google.api.field_behavior) = OPTIONAL];

  // Optional. Set to `true` to use an enhanced model for speech recognition.
  // If `use_enhanced_model` is set to true and the `model` field is not set,
  // then an appropriate enhanced model is chosen if an enhanced model exists
  // for
  // the audio.
  //
  // If `use_enhanced_model` is true and an enhanced version of the specified
  // model does not exist, then the speech is recognized using the standard
  // version of the specified model.
  bool use_enhanced_model = 14 [(google.api.field_behavior) = OPTIONAL];
}

message SpeakerDiarizationConfig {
  // Optional. If `true`, enables speaker detection for each recognized word in the top
  // alternative of the recognition result using a `speaker_tag` provided
  // in the WordInfo.
  bool enable_speaker_diarization = 1 [(google.api.field_behavior) = OPTIONAL];

  // Optional. Minimum number of speakers in the conversation. This range gives you more
  // flexibility by allowing the system to automatically determine the correct
  // number of speakers. If not set, the default value is `2`.
  int32 min_speaker_count = 2 [(google.api.field_behavior) = OPTIONAL];

  // Optional. Maximum number of speakers in the conversation. This range gives you more
  // flexibility by allowing the system to automatically determine the correct
  // number of speakers. If not set, the default value is `6`.
  int32 max_speaker_count = 3 [(google.api.field_behavior) = OPTIONAL];
}

// Description of audio data to be recognized.
message RecognitionMetadata {
  // Use case categories that the audio recognition request can be described
  // by.
  enum InteractionType {
    // Use case is either unknown or is something other than one of the other
    // values below.
    INTERACTION_TYPE_UNSPECIFIED = 0;

    // Multiple people in a conversation or discussion. For example in a
    // meeting with two or more people actively participating. Typically
    // all the primary people speaking would be in the same room (if not,
    // see PHONE_CALL)
    DISCUSSION = 1;

    // One or more persons lecturing or presenting to others, mostly
    // uninterrupted.
    PRESENTATION = 2;

    // A phone-call or video-conference in which two or more people, who are
    // not in the same room, are actively participating.
    PHONE_CALL = 3;

    // A recorded message intended for another person to listen to.
    VOICEMAIL = 4;

    // Professionally produced audio (eg. TV Show, Podcast).
    PROFESSIONALLY_PRODUCED = 5;

    // Transcribe spoken questions and queries into text.
    VOICE_SEARCH = 6;

    // Transcribe voice commands, such as for controlling a device.
    VOICE_COMMAND = 7;

    // Transcribe speech to text to create a written document, such as a
    // text-message, email or report.
    DICTATION = 8;
  }

  // Enumerates the types of capture settings describing an audio file.
  enum MicrophoneDistance {
    // Audio type is not known.
    MICROPHONE_DISTANCE_UNSPECIFIED = 0;

    // The audio was captured from a closely placed microphone. Eg. phone,
    // dictaphone, or handheld microphone. Generally if there speaker is within
    // 1 meter of the microphone.
    NEARFIELD = 1;

    // The speaker if within 3 meters of the microphone.
    MIDFIELD = 2;

    // The speaker is more than 3 meters away from the microphone.
    FARFIELD = 3;
  }

  // The original media the speech was recorded on.
  enum OriginalMediaType {
    // Unknown original media type.
    ORIGINAL_MEDIA_TYPE_UNSPECIFIED = 0;

    // The speech data is an audio recording.
    AUDIO = 1;

    // The speech data originally recorded on a video.
    VIDEO = 2;
  }

  // The type of device the speech was recorded with.
  enum RecordingDeviceType {
    // The recording device is unknown.
    RECORDING_DEVICE_TYPE_UNSPECIFIED = 0;

    // Speech was recorded on a smartphone.
    SMARTPHONE = 1;

    // Speech was recorded using a personal computer or tablet.
    PC = 2;

    // Speech was recorded over a phone line.
    PHONE_LINE = 3;

    // Speech was recorded in a vehicle.
    VEHICLE = 4;

    // Speech was recorded outdoors.
    OTHER_OUTDOOR_DEVICE = 5;

    // Speech was recorded indoors.
    OTHER_INDOOR_DEVICE = 6;
  }

  // Optional. The use case most closely describing the audio content to be recognized.
  InteractionType interaction_type = 1 [(google.api.field_behavior) = OPTIONAL];

  // Optional. The industry vertical to which this speech recognition request most closely
  // applies. This is most indicative of the topics contained in the audio.
  // Use the 6-digit NAICS code to identify the industry vertical - see
  // https://www.naics.com/search/.
  int32 naics_code = 3 [(google.api.field_behavior) = OPTIONAL];

  // Optional. The audio type that most closely describes the audio being recognized.
  MicrophoneDistance microphone_distance = 4 [(google.api.field_behavior) = OPTIONAL];

  // Optional. The original media the speech was recorded on.
  OriginalMediaType original_media_type = 5 [(google.api.field_behavior) = OPTIONAL];

  // Optional. The type of device the speech was recorded with.
  RecordingDeviceType recording_device_type = 6 [(google.api.field_behavior) = OPTIONAL];

  // Optional. The device used to make the recording.  Examples 'Nexus 5X' or
  // 'Polycom SoundStation IP 6000' or 'POTS' or 'VoIP' or
  // 'Cardioid Microphone'.
  string recording_device_name = 7 [(google.api.field_behavior) = OPTIONAL];

  // Optional. Mime type of the original audio file. For example `audio/m4a`,
  // `audio/x-alaw-basic`, `mp3`, `audio/3gpp`.
  // A list of possible audio mime types is maintained at
  // http://www.iana.org/assignments/media-types/media-types.xhtml#audio
  string original_audio_encoding = 8 [(google.api.field_behavior) = OPTIONAL];

  // Optional. Description of the content. Eg. "Recordings of federal supreme court
  // hearings from 2012".
  string audio_topic = 10 [(google.api.field_behavior) = OPTIONAL];
}

// Provides "hints" to the speech recognizer to favor specific words and phrases
// in the results.
message SpeechContext {
  // Optional. A list of strings containing words and phrases "hints" so that
  // the speech recognition is more likely to recognize them. This can be used
  // to improve the accuracy for specific words and phrases, for example, if
  // specific commands are typically spoken by the user. This can also be used
  // to add additional words to the vocabulary of the recognizer. See
  // [usage limits](https://cloud.google.com/speech-to-text/quotas#content).
  //
  // List items can also be set to classes for groups of words that represent
  // common concepts that occur in natural language. For example, rather than
  // providing phrase hints for every month of the year, using the $MONTH class
  // improves the likelihood of correctly transcribing audio that includes
  // months.
  repeated string phrases = 1 [(google.api.field_behavior) = OPTIONAL];

  // Optional. Hint Boost.
  // Positive value will increase the probability that a specific phrase will be
  // recognized over other similar sounding phrases. The higher the boost, the
  // higher the chance of false positive recognition as well.
  // Negative boost values would correspond to anti-biasing. Anti-biasing is not
  // enabled, so negative boost will simply be ignored. Though `boost` can
  // accept a wide range of positive values, most use cases are best served with
  // values between 0 and 20. We recommend using a binary search approach to
  // finding the optimal value for your use case.
  float boost = 2 [(google.api.field_behavior) = OPTIONAL];
}

// Contains audio data in the encoding specified in the `RecognitionConfig`.
// Either `content` or `uri` must be supplied. Supplying both or neither
// returns [google.rpc.Code.INVALID_ARGUMENT][google.rpc.Code.INVALID_ARGUMENT]. See
// [content limits](https://cloud.google.com/speech-to-text/quotas#content).
message RecognitionAudio {
  // *Optional* The audio source, which is either inline content or a Google
  // Cloud Storage uri.
  oneof audio_source {
    // The audio data bytes encoded as specified in
    // `RecognitionConfig`. Note: as with all bytes fields, proto buffers use a
    // pure binary representation, whereas JSON representations use base64.
    bytes content = 1;

    // URI that points to a file that contains audio data bytes as specified in
    // `RecognitionConfig`. The file must not be compressed (for example, gzip).
    // Currently, only Google Cloud Storage URIs are
    // supported, which must be specified in the following format:
    // `gs://bucket_name/object_name` (other URI formats return
    // [google.rpc.Code.INVALID_ARGUMENT][google.rpc.Code.INVALID_ARGUMENT]). For more information, see
    // [Request URIs](https://cloud.google.com/storage/docs/reference-uris).
    string uri = 2;
  }
}

// The only message returned to the client by the `Recognize` method. It
// contains the result as zero or more sequential [SpeechRecognitionResult][google.cloud.speech.v2beta1.SpeechRecognitionResult]
// messages.
message RecognizeResponse {
  // Output only. Sequential list of transcription results corresponding to sequential
  // portions of audio.
  repeated SpeechRecognitionResult results = 2 [(google.api.field_behavior) = OUTPUT_ONLY];
}

// The only message returned to the client by the `LongRunningRecognize` method.
// It contains the result as zero or more sequential [SpeechRecognitionResult][google.cloud.speech.v2beta1.SpeechRecognitionResult]
// messages. It is included in the `result.response` field of the `Operation`
// returned by the `GetOperation` call of the `google::longrunning::Operations`
// service.
message LongRunningRecognizeResponse {
  // Output only. Sequential list of transcription results corresponding to
  // sequential portions of audio.
  repeated SpeechRecognitionResult results = 2 [(google.api.field_behavior) = OUTPUT_ONLY];
}

// Describes the progress of a long-running `LongRunningRecognize` call. It is
// included in the `metadata` field of the `Operation` returned by the
// `GetOperation` call of the `google::longrunning::Operations` service.
message LongRunningRecognizeMetadata {
  // Output only. Approximate percentage of audio processed thus far. Guaranteed to be 100
  // when the audio is fully processed and the results are available.
  int32 progress_percent = 1 [(google.api.field_behavior) = OUTPUT_ONLY];

  // Output only. Time when the request was received.
  google.protobuf.Timestamp start_time = 2 [(google.api.field_behavior) = OUTPUT_ONLY];

  // Output only. Time of the most recent processing update.
  google.protobuf.Timestamp last_update_time = 3 [(google.api.field_behavior) = OUTPUT_ONLY];
}

// `StreamingRecognizeResponse` is the only message returned to the client by
// `StreamingRecognize`. A series of zero or more `StreamingRecognizeResponse`
// messages are streamed back to the client. If there is no recognizable
// audio, and `single_utterance` is set to false, then no messages are streamed
// back to the client.
//
// Here is an example of a series of ten `StreamingRecognizeResponse`s that
// might be returned while processing audio:
//
// 1. results { alternatives { transcript: "tube" } stability: 0.01 }
//
// 2. results { alternatives { transcript: "to be a" } stability: 0.01 }
//
// 3. results { alternatives { transcript: "to be" } stability: 0.9 }
//    results { alternatives { transcript: " or not to be" } stability: 0.01 }
//
// 4. results { alternatives { transcript: "to be or not to be"
//                             confidence: 0.92 }
//              alternatives { transcript: "to bee or not to bee" }
//              is_final: true }
//
// 5. results { alternatives { transcript: " that's" } stability: 0.01 }
//
// 6. results { alternatives { transcript: " that is" } stability: 0.9 }
//    results { alternatives { transcript: " the question" } stability: 0.01 }
//
// 7. results { alternatives { transcript: " that is the question"
//                             confidence: 0.98 }
//              alternatives { transcript: " that was the question" }
//              is_final: true }
//
// Notes:
//
// - Only two of the above responses #4 and #7 contain final results; they are
//   indicated by `is_final: true`. Concatenating these together generates the
//   full transcript: "to be or not to be that is the question".
//
// - The others contain interim `results`. #3 and #6 contain two interim
//   `results`: the first portion has a high stability and is less likely to
//   change; the second portion has a low stability and is very likely to
//   change. A UI designer might choose to show only high stability `results`.
//
// - The specific `stability` and `confidence` values shown above are only for
//   illustrative purposes. Actual values may vary.
//
// - In each response, only one of these fields will be set:
//     `error`,
//     `speech_event_type`, or
//     one or more (repeated) `results`.
message StreamingRecognizeResponse {
  // Indicates the type of speech event.
  enum SpeechEventType {
    // No speech event specified.
    SPEECH_EVENT_TYPE_UNSPECIFIED = 0;

    // This event indicates that the server has detected the end of the user's
    // speech utterance and expects no additional speech. Therefore, the server
    // will not process additional audio (although it may subsequently return
    // additional results). The client should stop sending additional audio
    // data, half-close the gRPC connection, and wait for any additional results
    // until the server closes the gRPC connection. This event is only sent if
    // `single_utterance` was set to `true`, and is not used otherwise.
    END_OF_SINGLE_UTTERANCE = 1;
  }

  // Output only. If set, returns a [google.rpc.Status][google.rpc.Status] message that
  // specifies the error for the operation.
  google.rpc.Status error = 1 [(google.api.field_behavior) = OUTPUT_ONLY];

  // Output only. This repeated list contains zero or more results that
  // correspond to consecutive portions of the audio currently being processed.
  // It contains zero or one `is_final=true` result (the newly settled portion),
  // followed by zero or more `is_final=false` results (the interim results).
  repeated StreamingRecognitionResult results = 2 [(google.api.field_behavior) = OUTPUT_ONLY];

  // Output only. Indicates the type of speech event.
  SpeechEventType speech_event_type = 3 [(google.api.field_behavior) = OUTPUT_ONLY];
}

// A streaming speech recognition result corresponding to a portion of the audio
// that is currently being processed.
message StreamingRecognitionResult {
  // Output only. May contain one or more recognition hypotheses (up to the
  // maximum specified in `max_alternatives`).
  // These alternatives are ordered in terms of accuracy, with the top (first)
  // alternative being the most probable, as ranked by the recognizer.
  repeated SpeechRecognitionAlternative alternatives = 1 [(google.api.field_behavior) = OUTPUT_ONLY];

  // Output only. If `false`, this `StreamingRecognitionResult` represents an
  // interim result that may change. If `true`, this is the final time the
  // speech service will return this particular `StreamingRecognitionResult`,
  // the recognizer will not return any further hypotheses for this portion of
  // the transcript and corresponding audio.
  bool is_final = 2 [(google.api.field_behavior) = OUTPUT_ONLY];

  // Output only. An estimate of the likelihood that the recognizer will not
  // change its guess about this interim result. Values range from 0.0
  // (completely unstable) to 1.0 (completely stable).
  // This field is only provided for interim results (`is_final=false`).
  // The default of 0.0 is a sentinel value indicating `stability` was not set.
  float stability = 3 [(google.api.field_behavior) = OUTPUT_ONLY];

  // Output only. Time offset of the end of this result relative to the
  // beginning of the audio.
  google.protobuf.Duration result_end_time = 4 [(google.api.field_behavior) = OUTPUT_ONLY];

  // Output only. For multi-channel audio, this is the channel number corresponding to the
  // recognized result for the audio from that channel.
  // For `audio_channel_count` = N, its output values can range from `1` to `N`.
  int32 channel_tag = 5 [(google.api.field_behavior) = OUTPUT_ONLY];

  // Output only. The
  // [BCP-47](https://www.rfc-editor.org/rfc/bcp/bcp47.txt) language tag of the
  // language in this result. This language code was detected to have the most
  // likelihood of being spoken in the audio.
  string language_code = 6 [(google.api.field_behavior) = OUTPUT_ONLY];
}

// A speech recognition result corresponding to a portion of the audio.
message SpeechRecognitionResult {
  // Output only. May contain one or more recognition hypotheses (up to the
  // maximum specified in `max_alternatives`).
  // These alternatives are ordered in terms of accuracy, with the top (first)
  // alternative being the most probable, as ranked by the recognizer.
  repeated SpeechRecognitionAlternative alternatives = 1 [(google.api.field_behavior) = OUTPUT_ONLY];

  // Output only. For multi-channel audio, this is the channel number corresponding to the
  // recognized result for the audio from that channel.
  // For `audio_channel_count` = N, its output values can range from `1` to `N`.
  int32 channel_tag = 2 [(google.api.field_behavior) = OUTPUT_ONLY];

  // Output only. The
  // [BCP-47](https://www.rfc-editor.org/rfc/bcp/bcp47.txt) language tag of the
  // language in this result. This language code was detected to have the most
  // likelihood of being spoken in the audio.
  string language_code = 5 [(google.api.field_behavior) = OUTPUT_ONLY];
}

// Alternative hypotheses (a.k.a. n-best list).
message SpeechRecognitionAlternative {
  // Output only. Transcript text representing the words that the user spoke.
  string transcript = 1 [(google.api.field_behavior) = OUTPUT_ONLY];

  // Output only. The confidence estimate between 0.0 and 1.0. A higher number
  // indicates an estimated greater likelihood that the recognized words are
  // correct. This field is set only for the top alternative of a non-streaming
  // result or, of a streaming result where `is_final=true`.
  // This field is not guaranteed to be accurate and users should not rely on it
  // to be always provided.
  // The default of 0.0 is a sentinel value indicating `confidence` was not set.
  float confidence = 2 [(google.api.field_behavior) = OUTPUT_ONLY];

  // Output only. A list of word-specific information for each recognized word.
  // Note: When `enable_speaker_diarization` is true, you will see all the words
  // from the beginning of the audio.
  repeated WordInfo words = 3 [(google.api.field_behavior) = OUTPUT_ONLY];
}

// Word-specific information for recognized words.
message WordInfo {
  // Output only. Time offset relative to the beginning of the audio,
  // and corresponding to the start of the spoken word.
  // This field is only set if `enable_word_time_offsets=true` and only
  // in the top hypothesis.
  // This is an experimental feature and the accuracy of the time offset can
  // vary.
  google.protobuf.Duration start_offset = 1 [(google.api.field_behavior) = OUTPUT_ONLY];

  // Output only. Time offset relative to the beginning of the audio,
  // and corresponding to the end of the spoken word.
  // This field is only set if `enable_word_time_offsets=true` and only
  // in the top hypothesis.
  // This is an experimental feature and the accuracy of the time offset can
  // vary.
  google.protobuf.Duration end_offset = 2 [(google.api.field_behavior) = OUTPUT_ONLY];

  // Output only. The word corresponding to this set of information.
  string word = 3 [(google.api.field_behavior) = OUTPUT_ONLY];

  // Output only. The confidence estimate between 0.0 and 1.0. A higher number
  // indicates an estimated greater likelihood that the recognized words are
  // correct. This field is set only for the top alternative of a non-streaming
  // result or, of a streaming result where `is_final=true`.
  // This field is not guaranteed to be accurate and users should not rely on it
  // to be always provided.
  // The default of 0.0 is a sentinel value indicating `confidence` was not set.
  float confidence = 4 [(google.api.field_behavior) = OUTPUT_ONLY];

  // Output only. A distinct integer value is assigned for every speaker within
  // the audio. This field specifies which one of those speakers was detected to
  // have spoken this word. Value ranges from `1` to
  // `diarization_config.max_speaker_count` . `speaker_tag` is set if
  // `diarization_config.enable_speaker_diarization` = `true` and only in the
  // top alternative.
  int32 speaker_tag = 5 [(google.api.field_behavior) = OUTPUT_ONLY];
}
